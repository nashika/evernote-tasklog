// Generated by CoffeeScript 1.9.3
(function() {
  var DataSource, Evernote, async, config, core,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  async = require('async');

  Evernote = require('evernote').Evernote;

  core = require('./core');

  config = require('../config');

  DataSource = (function() {
    function DataSource() {
      this._findNotesMeta = bind(this._findNotesMeta, this);
      this._parseNote = bind(this._parseNote, this);
      this._saveLocalNotes = bind(this._saveLocalNotes, this);
      this._loadRemoteNote = bind(this._loadRemoteNote, this);
      this._saveLocalSyncState = bind(this._saveLocalSyncState, this);
      this._loadLocalSyncState = bind(this._loadLocalSyncState, this);
      this._loadRemoteSyncState = bind(this._loadRemoteSyncState, this);
      this.sync = bind(this.sync, this);
    }


    /**
     * @public
     * @param {function} callback
     */

    DataSource.prototype.sync = function(callback) {
      var lastSyncChunk, localSyncState, noteStore, remoteSyncState;
      noteStore = core.client.getNoteStore();
      localSyncState = null;
      remoteSyncState = null;
      lastSyncChunk = null;
      return async.waterfall([
        (function(_this) {
          return function(callback) {
            return _this._loadLocalSyncState(callback);
          };
        })(this), (function(_this) {
          return function(syncState, callback) {
            localSyncState = syncState;
            return callback();
          };
        })(this), (function(_this) {
          return function(callback) {
            return _this._loadRemoteSyncState(callback);
          };
        })(this), (function(_this) {
          return function(syncState, callback) {
            remoteSyncState = syncState;
            return callback();
          };
        })(this), (function(_this) {
          return function(callback) {
            core.loggers.system.info("Sync start. localUSN=" + localSyncState.updateCount + " remoteUSN=" + remoteSyncState.updateCount);
            return async.whilst((function() {
              return localSyncState.updateCount < remoteSyncState.updateCount;
            }), function(callback) {
              var syncChunkFilter;
              core.loggers.system.info("Get sync chunk start. startUSN=" + localSyncState.updateCount);
              syncChunkFilter = new Evernote.SyncChunkFilter();
              syncChunkFilter.includeNotes = true;
              syncChunkFilter.includeExpunged = true;
              return async.waterfall([
                function(callback) {
                  return noteStore.getFilteredSyncChunk(localSyncState.updateCount, 100, syncChunkFilter, callback);
                }, function(syncChunk, callback) {
                  lastSyncChunk = syncChunk;
                  return callback();
                }, function(callback) {
                  return _this._saveLocalNotes(lastSyncChunk.notes, callback);
                }, function(callback) {
                  localSyncState.updateCount = lastSyncChunk.chunkHighUSN;
                  return callback();
                }, function(callback) {
                  return _this._saveLocalSyncState(localSyncState, callback);
                }, function(callback) {
                  core.loggers.system.info("Get sync chunk end. endUSN=" + localSyncState.updateCount);
                  return callback();
                }
              ], callback);
            }, function(err) {
              if (err) {
                return callback(err);
              }
              core.loggers.system.info("Sync end. localUSN=" + localSyncState.updateCount + " remoteUSN=" + remoteSyncState.updateCount);
              return callback();
            });
          };
        })(this)
      ], callback);
    };


    /**
     * @protected
     * @param {function} callback
     */

    DataSource.prototype._loadRemoteSyncState = function(callback) {
      var noteStore;
      noteStore = core.client.getNoteStore();
      return noteStore.getSyncState((function(_this) {
        return function(err, syncState) {
          if (err) {
            return callback(err);
          }
          return callback(null, syncState);
        };
      })(this));
    };


    /**
     * @protected
     * @param {function} callback
     */

    DataSource.prototype._loadLocalSyncState = function(callback) {
      return core.db.syncStates.find({
        _id: 1
      }, (function(_this) {
        return function(err, docs) {
          if (err) {
            return callback(err);
          }
          if (docs.length === 0) {
            return callback(null, {
              updateCount: 0
            });
          } else {
            return callback(null, docs[0]);
          }
        };
      })(this));
    };


    /**
     * @protected
     * @param {Object} syncState
     * @param {function} callback
     */

    DataSource.prototype._saveLocalSyncState = function(syncState, callback) {
      syncState._id = 1;
      return core.db.syncStates.update({
        _id: 1
      }, syncState, {
        upsert: true
      }, (function(_this) {
        return function(err, numReplaced, newDoc) {
          if (err) {
            return callback(err);
          }
          core.loggers.system.debug("Set client sync state update count to " + syncState.updateCount);
          return callback();
        };
      })(this));
    };


    /**
     * @protected
     * @param {string} guid
     * @param {function} callback
     */

    DataSource.prototype._loadRemoteNote = function(guid, callback) {
      var lastNote, noteStore;
      noteStore = core.client.getNoteStore();
      lastNote = null;
      return async.waterfall([
        (function(_this) {
          return function(callback) {
            return noteStore.getNote(guid, true, false, false, false, callback);
          };
        })(this), (function(_this) {
          return function(note, callback) {
            lastNote = note;
            return core.db.notes.update({
              guid: note.guid
            }, note, {
              upsert: true
            }, callback);
          };
        })(this), (function(_this) {
          return function(numReplaced, newDoc, callback) {
            core.loggers.system.debug("A note is loaded. guid=" + newDoc.guid + " title=" + newDoc.title);
            return callback();
          };
        })(this), (function(_this) {
          return function(callback) {
            return _this._parseNote(lastNote, callback);
          };
        })(this)
      ], callback);
    };


    /**
     * @protected
     * @param {Array} notesMeta
     * @param {function} callback
     */

    DataSource.prototype._saveLocalNotes = function(notes, callback) {
      if (!notes) {
        return callback();
      }
      core.loggers.system.debug("Save local notes start. notes.count=" + notes.length);
      return async.eachSeries(notes, (function(_this) {
        return function(note, callback) {
          var localNote;
          localNote = null;
          return async.waterfall([
            function(callback) {
              return core.db.notes.find({
                guid: note.guid
              }, callback);
            }, function(docs, callback) {
              localNote = docs.length === 0 ? null : docs[0];
              if (!localNote || localNote.updateSequenceNum < note.updateSequenceNum) {
                core.loggers.system.debug("Upsert note start. guid=" + note.guid + ", title=" + note.title);
                return async.waterfall([
                  function(callback) {
                    return core.db.notes.update({
                      guid: note.guid
                    }, note, {
                      upsert: true
                    }, callback);
                  }, function(numReplaced, newDoc, callback) {
                    core.loggers.system.debug("Upsert note end. guid=" + note.guid + ", title=" + note.title);
                    return callback();
                  }
                ], callback);
              } else {
                core.loggers.system.debug("Upsert note skipped. guid=" + note.guid + ", title=" + note.title);
                return callback();
              }
            }
          ], callback);
        };
      })(this), callback);
    };


    /**
     * @protected
     * @param {Object} note
     * @param {function} callback
     */

    DataSource.prototype._parseNote = function(note, callback) {
      var attributesText, clearLine, content, dateText, i, j, len, len1, line, matches, person, profitLogs, ref, ref1, spentHour, spentMinute, spentTimeText, timeLog, timeLogs, timeText;
      content = note.content;
      timeLogs = [];
      profitLogs = [];
      content = content.replace(/\r\n|\r|\n|<br\/>|<\/div>|<\/ul>|<\/li>/g, '<>');
      ref = content.split('<>');
      for (i = 0, len = ref.length; i < len; i++) {
        line = ref[i];
        clearLine = line.replace(/<[^>]*>/g, '');
        if (matches = clearLine.match(/(.*)[@ï¼ ](\d{2,4}[\/\-]\d{1,2}[\/\-]\d{1,2}.+)/)) {
          timeLog = {
            noteGuid: note.guid,
            comment: matches[1],
            allDay: true,
            date: null,
            person: null,
            spentTime: null
          };
          attributesText = matches[2];
          dateText = (matches = attributesText.match(/\d{2,4}[\/\-]\d{1,2}[\/\-]\d{1,2}/)) ? matches[0] : '';
          timeText = (matches = attributesText.match(/\d{1,2}:\d{1,2}:\d{1,2}|\d{1,2}:\d{1,2}/)) ? matches[0] : '';
          timeLog.date = new Date(dateText + ' ' + timeText);
          if (timeText) {
            timeLog.allDay = false;
          }
          ref1 = config.persons;
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            person = ref1[j];
            if (attributesText.indexOf(person) !== -1) {
              timeLog.person = person;
            }
          }
          if (matches = attributesText.match(/\d+h\d+m|\d+m|\d+h|\d+\.\d+h/i)) {
            spentTimeText = matches[0];
            spentHour = (matches = spentTimeText.match(/(\d+)h/)) ? parseInt(matches[1]) : 0;
            spentMinute = (matches = spentTimeText.match(/(\d+)m/)) ? parseInt(matches[1]) : 0;
            timeLog.spentTime = spentHour * 60 + spentMinute;
          }
          if (timeLog.date && timeLog.person) {
            timeLogs.push(timeLog);
          }
        }
        if (matches = clearLine.match(/(.*)[@ï¼ ][\\ï¿¥](.+)/i)) {
          profitLogs.push({
            noteGuid: note.guid,
            comment: matches[1],
            profit: parseInt(matches[2].replace(/,/g, ''))
          });
        }
      }
      return async.series([
        (function(_this) {
          return function(callback) {
            return core.db.timeLogs.remove({
              noteGuid: note.guid
            }, {
              multi: true
            }, function(err, numRemoved) {
              if (err) {
                return callback(err);
              }
              core.loggers.system.debug("Remove " + numRemoved + " timeLogs.");
              return callback();
            });
          };
        })(this), (function(_this) {
          return function(callback) {
            return core.db.profitLogs.remove({
              noteGuid: note.guid
            }, {
              multi: true
            }, function(err, numRemoved) {
              if (err) {
                return callback(err);
              }
              core.loggers.system.debug("Remove " + numRemoved + " profitLogs.");
              return callback();
            });
          };
        })(this), (function(_this) {
          return function(callback) {
            return core.db.timeLogs.insert(timeLogs, function(err, newDocs) {
              if (err) {
                return callback(err);
              }
              core.loggers.system.debug("Insert " + newDocs.length + " timeLogs.");
              return callback();
            });
          };
        })(this), (function(_this) {
          return function(callback) {
            return core.db.profitLogs.insert(profitLogs, function(err, newDocs) {
              if (err) {
                return callback(err);
              }
              core.loggers.system.debug("Insert " + newDocs.length + " profitLogs.");
              return callback();
            });
          };
        })(this)
      ], (function(_this) {
        return function(err) {
          if (err) {
            callback(err);
          }
          return callback();
        };
      })(this));
    };

    DataSource.prototype._findNotesMeta = function(words, callback) {
      var noteFilter, noteStore, resultSpec;
      noteStore = core.client.getNoteStore();
      noteFilter = new Evernote.NoteFilter();
      if (words) {
        noteFilter.words = words;
      }
      resultSpec = new Evernote.NotesMetadataResultSpec();
      return noteStore.findNotesMetadata(noteFilter, 0, 100, resultSpec, (function(_this) {
        return function(err, notesMeta) {
          if (err) {
            return callback(err);
          }
          return callback(null, notesMeta.notes);
        };
      })(this));
    };

    return DataSource;

  })();

  module.exports = new DataSource();

}).call(this);

//# sourceMappingURL=data-source.js.map
