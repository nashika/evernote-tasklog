// Generated by CoffeeScript 1.9.3
(function() {
  var Datastore, Evernote, LinkedNotebookModel, NoteModel, NotebookModel, SearchModel, SyncStateModel, TagModel, UserModel, Www, async, config, core, log4js, path,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  path = require('path');

  async = require('async');

  log4js = require('log4js');

  Evernote = require('evernote').Evernote;

  Datastore = require('nedb');

  core = require('./core');

  config = require('../config');

  UserModel = require('./models/user-model');

  SyncStateModel = require('./models/sync-state-model');

  NoteModel = require('./models/note-model');

  NotebookModel = require('./models/notebook-model');

  TagModel = require('./models/tag-model');

  SearchModel = require('./models/search-model');

  LinkedNotebookModel = require('./models/linked-notebook-model');

  Www = (function() {
    function Www() {
      this.sync = bind(this.sync, this);
    }

    Www.prototype.SYNC_CHUNK_COUNT = 100;


    /**
     * @public
     */

    Www.prototype.main = function(app, server) {
      log4js.configure(path.normalize(__dirname + '/../log4js-config.json'), {
        cwd: path.normalize(__dirname + '/..')
      });
      core.loggers.system = log4js.getLogger('system');
      core.loggers.access = log4js.getLogger('access');
      core.loggers.error = log4js.getLogger('error');
      core.app = app;
      core.server = server;
      core.www = this;
      core.app.locals.core = core;
      return core.loggers.system.info('Initialize web server finished.');
    };

    Www.prototype.initUser = function(username, token, sandbox, callback) {
      if (core.users[username]) {
        core.loggers.system.info('Init user finished. already initialized.');
        return callback();
      }
      core.users[username] = {};
      core.users[username].client = new Evernote.Client({
        token: token,
        sandbox: sandbox
      });
      return async.waterfall([
        (function(_this) {
          return function(callback) {
            var userStore;
            userStore = core.users[username].client.getUserStore();
            return userStore.getUser(callback);
          };
        })(this), (function(_this) {
          return function(user, callback) {
            core.users[username].user = user;
            return callback();
          };
        })(this), (function(_this) {
          return function(callback) {
            var dbPath;
            core.users[username].db = {};
            dbPath = __dirname + '/../db/' + core.users[username].user.username + '/';
            core.users[username].db.users = new Datastore({
              filename: dbPath + 'users.db',
              autoload: true
            });
            core.users[username].db.syncStates = new Datastore({
              filename: dbPath + 'sync-states.db',
              autoload: true
            });
            core.users[username].db.notes = new Datastore({
              filename: dbPath + 'notes.db',
              autoload: true
            });
            core.users[username].db.notebooks = new Datastore({
              filename: dbPath + 'notebooks.db',
              autoload: true
            });
            core.users[username].db.tags = new Datastore({
              filename: dbPath + 'tags.db',
              autoload: true
            });
            core.users[username].db.searches = new Datastore({
              filename: dbPath + 'searches.db',
              autoload: true
            });
            core.users[username].db.linkedNotebooks = new Datastore({
              filename: dbPath + 'linked-notebooks.db',
              autoload: true
            });
            core.users[username].db.timeLogs = new Datastore({
              filename: dbPath + 'time-logs.db',
              autoload: true
            });
            core.users[username].db.profitLogs = new Datastore({
              filename: dbPath + 'profit-logs.db',
              autoload: true
            });
            return callback();
          };
        })(this), (function(_this) {
          return function(callback) {
            return _this.sync(username, callback);
          };
        })(this)
      ], (function(_this) {
        return function(err) {
          if (err) {
            return core.loggers.error.error(err);
          }
          core.loggers.system.info("Init user finished. user:" + username + " data was initialized.");
          return callback();
        };
      })(this));
    };


    /**
     * @public
     * @param {function} callback
     */

    Www.prototype.sync = function(username, callback) {
      var lastSyncChunk, localSyncState, noteStore, remoteSyncState, user;
      noteStore = core.users[username].client.getNoteStore();
      user = null;
      localSyncState = null;
      remoteSyncState = null;
      lastSyncChunk = null;
      return async.waterfall([
        (function(_this) {
          return function(callback) {
            return UserModel.prototype.s_loadRemote(username, callback);
          };
        })(this), (function(_this) {
          return function(remoteUser, callback) {
            user = remoteUser;
            return callback();
          };
        })(this), (function(_this) {
          return function(callback) {
            return UserModel.prototype.s_saveLocal(username, user, callback);
          };
        })(this), (function(_this) {
          return function(callback) {
            return SyncStateModel.prototype.s_loadLocal(username, callback);
          };
        })(this), (function(_this) {
          return function(syncState, callback) {
            localSyncState = syncState;
            return callback();
          };
        })(this), (function(_this) {
          return function(callback) {
            return SyncStateModel.prototype.s_loadRemote(username, callback);
          };
        })(this), (function(_this) {
          return function(syncState, callback) {
            remoteSyncState = syncState;
            return callback();
          };
        })(this), (function(_this) {
          return function(callback) {
            core.loggers.system.info("Sync start. localUSN=" + localSyncState.updateCount + " remoteUSN=" + remoteSyncState.updateCount);
            return async.whilst((function() {
              return localSyncState.updateCount < remoteSyncState.updateCount;
            }), function(callback) {
              var syncChunkFilter;
              core.loggers.system.info("Get sync chunk start. startUSN=" + localSyncState.updateCount);
              syncChunkFilter = new Evernote.SyncChunkFilter();
              syncChunkFilter.includeNotes = true;
              syncChunkFilter.includeNotebooks = true;
              syncChunkFilter.includeTags = true;
              syncChunkFilter.includeSearches = true;
              syncChunkFilter.includeExpunged = true;
              return async.waterfall([
                function(callback) {
                  return noteStore.getFilteredSyncChunk(localSyncState.updateCount, _this.SYNC_CHUNK_COUNT, syncChunkFilter, callback);
                }, function(syncChunk, callback) {
                  lastSyncChunk = syncChunk;
                  return callback();
                }, function(callback) {
                  return NoteModel.prototype.s_saveLocal(username, lastSyncChunk.notes, callback);
                }, function(callback) {
                  return NoteModel.prototype.s_removeLocal(username, lastSyncChunk.expungedNotes, callback);
                }, function(callback) {
                  return NotebookModel.prototype.s_saveLocal(username, lastSyncChunk.notebooks, callback);
                }, function(callback) {
                  return NotebookModel.prototype.s_removeLocal(username, lastSyncChunk.expungedNotebooks, callback);
                }, function(callback) {
                  return TagModel.prototype.s_saveLocal(username, lastSyncChunk.tags, callback);
                }, function(callback) {
                  return TagModel.prototype.s_removeLocal(username, lastSyncChunk.expungedTags, callback);
                }, function(callback) {
                  return SearchModel.prototype.s_saveLocal(username, lastSyncChunk.searches, callback);
                }, function(callback) {
                  return SearchModel.prototype.s_removeLocal(username, lastSyncChunk.expungedSearches, callback);
                }, function(callback) {
                  return LinkedNotebookModel.prototype.s_saveLocal(username, lastSyncChunk.linkedNotebooks, callback);
                }, function(callback) {
                  return LinkedNotebookModel.prototype.s_removeLocal(username, lastSyncChunk.expungedLinkedNotebooks, callback);
                }, function(callback) {
                  localSyncState.updateCount = lastSyncChunk.chunkHighUSN;
                  return callback();
                }, function(callback) {
                  return SyncStateModel.prototype.s_saveLocal(username, localSyncState, callback);
                }, function(callback) {
                  core.loggers.system.info("Get sync chunk end. endUSN=" + localSyncState.updateCount);
                  return callback();
                }
              ], callback);
            }, function(err) {
              if (err) {
                return callback(err);
              }
              core.loggers.system.info("Sync end. localUSN=" + localSyncState.updateCount + " remoteUSN=" + remoteSyncState.updateCount);
              return callback();
            });
          };
        })(this)
      ], callback);
    };

    return Www;

  })();

  module.exports = new Www();

}).call(this);

//# sourceMappingURL=www.js.map
