// Generated by CoffeeScript 1.9.3
(function() {
  var Evernote, LinkedNotebookModel, NoteModel, NotebookModel, ProfitLogsModel, SearchModel, SettingModel, SyncStateModel, TagModel, TimeLogsModel, UserModel, Www, async, config, core, log4js, path,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  path = require('path');

  async = require('async');

  log4js = require('log4js');

  Evernote = require('evernote').Evernote;

  core = require('./core');

  config = require('../config');

  LinkedNotebookModel = require('./models/linked-notebook-model');

  NoteModel = require('./models/note-model');

  NotebookModel = require('./models/notebook-model');

  ProfitLogsModel = require('./models/profit-log-model');

  SearchModel = require('./models/search-model');

  SettingModel = require('./models/setting-model');

  SyncStateModel = require('./models/sync-state-model');

  TagModel = require('./models/tag-model');

  TimeLogsModel = require('./models/time-log-model');

  UserModel = require('./models/user-model');

  Www = (function() {
    function Www() {
      this.sync = bind(this.sync, this);
    }

    Www.prototype.SYNC_CHUNK_COUNT = 100;


    /**
     * @public
     */

    Www.prototype.main = function(app, server) {
      log4js.configure(path.normalize(__dirname + '/../log4js-config.json'), {
        cwd: path.normalize(__dirname + '/..')
      });
      core.loggers.system = log4js.getLogger('system');
      core.loggers.access = log4js.getLogger('access');
      core.loggers.error = log4js.getLogger('error');
      core.app = app;
      core.server = server;
      core.www = this;
      core.app.locals.core = core;
      core.models.settings = new SettingModel();
      return core.loggers.system.info('Initialize web server finished.');
    };

    Www.prototype.initUser = function(username, token, sandbox, callback) {
      if (core.users[username]) {
        core.loggers.system.info('Init user finished. already initialized.');
        return callback();
      }
      core.users[username] = {};
      core.users[username].client = new Evernote.Client({
        token: token,
        sandbox: sandbox
      });
      return async.waterfall([
        (function(_this) {
          return function(callback) {
            var userStore;
            userStore = core.users[username].client.getUserStore();
            return userStore.getUser(callback);
          };
        })(this), (function(_this) {
          return function(user, callback) {
            core.users[username].user = user;
            return callback();
          };
        })(this), (function(_this) {
          return function(callback) {
            var dbPath;
            core.users[username].db = {};
            dbPath = __dirname + '/../db/' + core.users[username].user.username + '/';
            core.users[username].models = {
              users: new UserModel(username),
              syncStates: new SyncStateModel(username),
              notes: new NoteModel(username),
              notebooks: new NotebookModel(username),
              tags: new TagModel(username),
              searches: new SearchModel(username),
              linkedNotebooks: new LinkedNotebookModel(username),
              timeLogs: new TimeLogsModel(username),
              profitLogs: new ProfitLogsModel(username)
            };
            return callback();
          };
        })(this), (function(_this) {
          return function(callback) {
            return _this.sync(username, callback);
          };
        })(this)
      ], (function(_this) {
        return function(err) {
          if (err) {
            return core.loggers.error.error(err);
          }
          core.loggers.system.info("Init user finished. user:" + username + " data was initialized.");
          return callback();
        };
      })(this));
    };


    /**
     * @public
     * @param {function} callback
     */

    Www.prototype.sync = function(username, callback) {
      var lastSyncChunk, localSyncState, noteStore, remoteSyncState, user;
      noteStore = core.users[username].client.getNoteStore();
      user = null;
      localSyncState = null;
      remoteSyncState = null;
      lastSyncChunk = null;
      return async.waterfall([
        (function(_this) {
          return function(callback) {
            return core.users[username].models.users.loadRemote(callback);
          };
        })(this), (function(_this) {
          return function(remoteUser, callback) {
            user = remoteUser;
            return callback();
          };
        })(this), (function(_this) {
          return function(callback) {
            return core.users[username].models.users.saveLocal(user, callback);
          };
        })(this), (function(_this) {
          return function(callback) {
            return core.users[username].models.syncStates.loadLocal(callback);
          };
        })(this), (function(_this) {
          return function(syncState, callback) {
            localSyncState = syncState;
            return callback();
          };
        })(this), (function(_this) {
          return function(callback) {
            return core.users[username].models.syncStates.loadRemote(callback);
          };
        })(this), (function(_this) {
          return function(syncState, callback) {
            remoteSyncState = syncState;
            return callback();
          };
        })(this), (function(_this) {
          return function(callback) {
            core.loggers.system.info("Sync start. localUSN=" + localSyncState.updateCount + " remoteUSN=" + remoteSyncState.updateCount);
            return async.whilst((function() {
              return localSyncState.updateCount < remoteSyncState.updateCount;
            }), function(callback) {
              var syncChunkFilter;
              core.loggers.system.info("Get sync chunk start. startUSN=" + localSyncState.updateCount);
              syncChunkFilter = new Evernote.SyncChunkFilter();
              syncChunkFilter.includeNotes = true;
              syncChunkFilter.includeNotebooks = true;
              syncChunkFilter.includeTags = true;
              syncChunkFilter.includeSearches = true;
              syncChunkFilter.includeExpunged = true;
              return async.waterfall([
                function(callback) {
                  return noteStore.getFilteredSyncChunk(localSyncState.updateCount, _this.SYNC_CHUNK_COUNT, syncChunkFilter, callback);
                }, function(syncChunk, callback) {
                  lastSyncChunk = syncChunk;
                  return callback();
                }, function(callback) {
                  return core.users[username].models.notes.saveLocal(lastSyncChunk.notes, callback);
                }, function(callback) {
                  return core.users[username].models.notes.removeLocal(lastSyncChunk.expungedNotes, callback);
                }, function(callback) {
                  return core.users[username].models.notebooks.saveLocal(lastSyncChunk.notebooks, callback);
                }, function(callback) {
                  return core.users[username].models.notebooks.removeLocal(lastSyncChunk.expungedNotebooks, callback);
                }, function(callback) {
                  return core.users[username].models.tags.saveLocal(lastSyncChunk.tags, callback);
                }, function(callback) {
                  return core.users[username].models.tags.removeLocal(lastSyncChunk.expungedTags, callback);
                }, function(callback) {
                  return core.users[username].models.searches.saveLocal(lastSyncChunk.searches, callback);
                }, function(callback) {
                  return core.users[username].models.searches.removeLocal(lastSyncChunk.expungedSearches, callback);
                }, function(callback) {
                  return core.users[username].models.linkedNotebooks.saveLocal(lastSyncChunk.linkedNotebooks, callback);
                }, function(callback) {
                  return core.users[username].models.linkedNotebooks.removeLocal(lastSyncChunk.expungedLinkedNotebooks, callback);
                }, function(callback) {
                  localSyncState.updateCount = lastSyncChunk.chunkHighUSN;
                  return callback();
                }, function(callback) {
                  return core.users[username].models.syncStates.saveLocal(localSyncState, callback);
                }, function(callback) {
                  core.loggers.system.info("Get sync chunk end. endUSN=" + localSyncState.updateCount);
                  return callback();
                }
              ], callback);
            }, function(err) {
              if (err) {
                return callback(err);
              }
              core.loggers.system.info("Sync end. localUSN=" + localSyncState.updateCount + " remoteUSN=" + remoteSyncState.updateCount);
              return callback();
            });
          };
        })(this)
      ], callback);
    };

    return Www;

  })();

  module.exports = new Www();

}).call(this);

//# sourceMappingURL=www.js.map
