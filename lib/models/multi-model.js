// Generated by CoffeeScript 1.9.3
(function() {
  var Model, MultiModel, async, core, merge,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  async = require('async');

  merge = require('merge');

  core = require('../core');

  Model = require('./Model');

  MultiModel = (function(superClass) {
    extend(MultiModel, superClass);

    function MultiModel() {
      this.s_removeLocal = bind(this.s_removeLocal, this);
      this.s_saveLocalUpdateOnly = bind(this.s_saveLocalUpdateOnly, this);
      this.s_saveLocal = bind(this.s_saveLocal, this);
      this.s_countLocal = bind(this.s_countLocal, this);
      this.s_findLocal = bind(this.s_findLocal, this);
      return MultiModel.__super__.constructor.apply(this, arguments);
    }


    /**
     * @const
     * @type {Object}
     */

    MultiModel.prototype.DEFAULT_QUERY = {};


    /**
     * @const
     * @type {Object}
     */

    MultiModel.prototype.APPEND_QUERY = {};


    /**
     * @const
     * @type {Object}
     */

    MultiModel.prototype.DEFAULT_SORT = {
      updated: -1
    };


    /**
     * @const
     * @type {number}
     */

    MultiModel.prototype.DEFAULT_LIMIT = 50;


    /**
     * @public
     * @static
     * @param {Object} options
     * @param {function} callback
     */

    MultiModel.prototype.s_findLocal = function(options, callback) {
      var limit, query, ref, ref1, ref2, sort;
      if (indexOf.call(options, 'query') >= 0) {
        query = (ref = options.query) != null ? ref : merge(true, this.DEFAULT_QUERY);
        sort = (ref1 = options.sort) != null ? ref1 : merge(true, this.DEFAULT_SORT);
        limit = (ref2 = options.limit) != null ? ref2 : this.DEFAULT_LIMIT;
      } else {
        query = options != null ? options : merge(true, this.DEFAULT_QUERY);
        sort = merge(true, this.DEFAULT_SORT);
        limit = this.DEFAULT_LIMIT;
      }
      merge(query, this.APPEND_QUERY);
      core.loggers.system.debug("Find local " + this.PLURAL_NAME + " was started. query=" + (JSON.stringify(query)) + ", sort=" + (JSON.stringify(sort)) + ", limit=" + limit);
      return core.db[this.PLURAL_NAME].find(query).sort(sort).limit(limit).exec((function(_this) {
        return function(err, docs) {
          core.loggers.system.debug("Find local " + _this.PLURAL_NAME + " was " + (err ? 'failed' : 'succeed') + ". docs.length=" + docs.length);
          return callback(err, docs);
        };
      })(this));
    };


    /**
     * @public
     * @static
     * @param {Object} options
     * @param {function} callback
     */

    MultiModel.prototype.s_countLocal = function(options, callback) {
      var query;
      core.loggers.system.debug("Count local " + this.PLURAL_NAME + " was started. options=" + (JSON.stringify(options)));
      query = indexOf.call(options, 'query') >= 0 ? options.query : options;
      return core.db[this.PLURAL_NAME].count(query, (function(_this) {
        return function(err, count) {
          core.loggers.system.debug("Count local " + _this.PLURAL_NAME + " was " + (err ? 'failed' : 'succeed') + ". count=" + count);
          return callback(err, count);
        };
      })(this));
    };


    /**
     * @public
     * @static
     * @param {Array.<Object>|Object} docs
     * @param {function} callback
     */

    MultiModel.prototype.s_saveLocal = function(docs, callback) {
      if (!docs || docs.length === 0) {
        return callback();
      }
      if (!Array.isArray(docs)) {
        docs = [docs];
      }
      core.loggers.system.debug("Save local " + this.PLURAL_NAME + " was started. docs.count=" + docs.length);
      return async.eachSeries(docs, (function(_this) {
        return function(doc, callback) {
          core.loggers.system.trace("Upsert local " + _this.PLURAL_NAME + " was started. guid=" + doc.guid + ", title=" + doc[_this.TITLE_FIELD]);
          return core.db[_this.PLURAL_NAME].update({
            guid: doc.guid
          }, doc, {
            upsert: true
          }, function(err, numReplaced, newDoc) {
            core.loggers.system.trace("Upsert local " + _this.PLURAL_NAME + " was " + (err ? 'failed' : 'succeed') + ". guid=" + doc.guid + ", numReplaced=" + numReplaced);
            return callback(err);
          });
        };
      })(this), (function(_this) {
        return function(err) {
          core.loggers.system.debug("Save local " + _this.PLURAL_NAME + " was " + (err ? 'failed' : 'succeed') + ". docs.count=" + docs.length);
          return callback(err);
        };
      })(this));
    };


    /**
     * @public
     * @static
     * @param {Array.<Object>|Object} docs
     * @param {function} callback
     */

    MultiModel.prototype.s_saveLocalUpdateOnly = function(docs, callback) {
      if (!docs || docs.length === 0) {
        return callback();
      }
      if (!Array.isArray(docs)) {
        docs = [docs];
      }
      core.loggers.system.debug("Save local update only " + this.PLURAL_NAME + " was started. docs.count=" + docs.length);
      return async.eachSeries(docs, (function(_this) {
        return function(doc, callback) {
          var localDoc;
          localDoc = null;
          return async.waterfall([
            function(callback) {
              return core.db[_this.PLURAL_NAME].find({
                guid: doc.guid
              }, callback);
            }, function(docs, callback) {
              localDoc = docs.length === 0 ? null : docs[0];
              if (localDoc && localDoc.updateSequenceNum >= doc.updateSequenceNum) {
                core.loggers.system.trace("Upsert local " + _this.PLURAL_NAME + " was skipped. guid=" + doc.guid + ", title=" + doc[_this.TITLE_FIELD]);
                return callback();
              } else {
                core.loggers.system.trace("Upsert local " + _this.PLURAL_NAME + " was started. guid=" + doc.guid + ", title=" + doc[_this.TITLE_FIELD]);
                return async.waterfall([
                  function(callback) {
                    return core.db[_this.PLURAL_NAME].update({
                      guid: doc.guid
                    }, doc, {
                      upsert: true
                    }, callback);
                  }, function() {
                    var callback, i, newDoc, numReplaced;
                    numReplaced = arguments[0], newDoc = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), callback = arguments[i++];
                    core.loggers.system.trace("Upsert local " + _this.PLURAL_NAME + " was succeed. guid=" + doc.guid + ", numReplaced=" + numReplaced);
                    return callback();
                  }
                ], callback);
              }
            }
          ], callback);
        };
      })(this), (function(_this) {
        return function(err) {
          core.loggers.system.debug("Save local update only " + _this.PLURAL_NAME + " was " + (err ? 'failed' : 'succeed') + ". docs.count=" + docs.length);
          return callback(err);
        };
      })(this));
    };


    /**
     * @public
     * @static
     * @param {Array.<string>|string|Object} query
     * @param {function} callback
     */

    MultiModel.prototype.s_removeLocal = function(query, callback) {
      if (!query) {
        return callback();
      }
      if (Array.isArray(query)) {
        if (query.length === 0) {
          callback();
        }
        query = {
          guid: {
            $in: query
          }
        };
      }
      if (typeof query === 'string') {
        query = {
          guid: query
        };
      }
      core.loggers.system.debug("Remove local " + this.PLURAL_NAME + " was started. query=" + (JSON.stringify(query)));
      return core.db[this.PLURAL_NAME].remove(query, {
        multi: true
      }, (function(_this) {
        return function(err, numRemoved) {
          core.loggers.system.debug("Remove local " + _this.PLURAL_NAME + " was " + (err ? 'failed' : 'succeed') + ". numRemoved=" + numRemoved);
          return callback(err);
        };
      })(this));
    };

    return MultiModel;

  })(Model);

  module.exports = MultiModel;

}).call(this);

//# sourceMappingURL=multi-model.js.map
