// Generated by CoffeeScript 1.9.3
(function() {
  var MultiModel, NoteModel, async, core, merge,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  async = require('async');

  merge = require('merge');

  core = require('../core');

  MultiModel = require('./multi-model');

  NoteModel = (function(superClass) {
    extend(NoteModel, superClass);

    function NoteModel() {
      this._parseNote = bind(this._parseNote, this);
      this.reParseNotes = bind(this.reParseNotes, this);
      this.loadRemote = bind(this.loadRemote, this);
      this.getRemoteContent = bind(this.getRemoteContent, this);
      this.findLocal = bind(this.findLocal, this);
      return NoteModel.__super__.constructor.apply(this, arguments);
    }


    /**
     * @override
     */

    NoteModel.prototype.PLURAL_NAME = 'notes';


    /**
     * @override
     */

    NoteModel.prototype.TITLE_FIELD = 'title';


    /**
     * @override
     */

    NoteModel.prototype.APPEND_QUERY = {
      deleted: null
    };


    /**
     * @override
     */

    NoteModel.prototype.findLocal = function(options, callback) {
      return NoteModel.__super__.findLocal.call(this, options, (function(_this) {
        return function(err, notes) {
          var i, len, note, result, results;
          if (options.content) {
            return callback(null, notes);
          } else {
            results = [];
            for (i = 0, len = notes.length; i < len; i++) {
              note = notes[i];
              result = merge(true, note);
              result.content = null;
              results.push(result);
            }
            return callback(null, results);
          }
        };
      })(this));
    };


    /**
     * @public
     * @param {Object} query
     * @param {function} callback
     */

    NoteModel.prototype.getRemoteContent = function(options, callback) {
      options = merge(true, options, {
        content: true
      });
      return this.findLocal(options, (function(_this) {
        return function(err, notes) {
          var result;
          if (err) {
            return callback(err);
          }
          result = {
            count: notes.length,
            getRemoteContentCount: 0
          };
          return async.eachSeries(notes, function(note, callback) {
            if (note.content) {
              return callback();
            }
            return _this.loadRemote(note.guid, function(err, loadNote) {
              if (err) {
                return callback(err);
              }
              result.getRemoteContentCount++;
              return callback();
            });
          }, function(err) {
            if (err) {
              return callback(err);
            }
            return callback(null, result);
          });
        };
      })(this));
    };


    /**
     * @public
     * @param {string} guid
     * @param {function} callback
     */

    NoteModel.prototype.loadRemote = function(guid, callback) {
      var lastNote, noteStore;
      core.loggers.system.debug("Loading note from remote was started. guid=" + guid);
      noteStore = core.users[this._username].client.getNoteStore();
      lastNote = null;
      return async.waterfall([
        (function(_this) {
          return function(callback) {
            return noteStore.getNote(guid, true, false, false, false, callback);
          };
        })(this), (function(_this) {
          return function(note, callback) {
            core.loggers.system.debug("Loading note was succeed. guid=" + note.guid + " title=" + note[_this.TITLE_FIELD]);
            lastNote = note;
            core.loggers.system.debug("Saving note to local. guid=" + note.guid);
            return _this._datastore.update({
              guid: note.guid
            }, note, {
              upsert: true
            }, callback);
          };
        })(this), (function(_this) {
          return function() {
            var callback, i, newDoc, numReplaced;
            numReplaced = arguments[0], newDoc = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), callback = arguments[i++];
            core.loggers.system.debug("Saving note was succeed. guid=" + lastNote.guid + " numReplaced=" + numReplaced);
            return callback();
          };
        })(this), (function(_this) {
          return function(callback) {
            return _this._parseNote(lastNote, callback);
          };
        })(this)
      ], (function(_this) {
        return function(err) {
          if (err) {
            return callback(err);
          }
          core.loggers.system.debug("Loading note from remote was finished. note is loaded. guid=" + lastNote.guid + " title=" + lastNote.title);
          return callback(null, lastNote);
        };
      })(this));
    };


    /**
     * @public
     * @param {function} callback
     */

    NoteModel.prototype.reParseNotes = function(options, callback) {
      if (options == null) {
        options = {};
      }
      options.limit = 0;
      options.content = true;
      return this.findLocal(options, (function(_this) {
        return function(err, notes) {
          if (err) {
            return callback(err);
          }
          return async.eachSeries(notes, function(note, callback) {
            return _this._parseNote(note, callback);
          }, callback);
        };
      })(this));
    };


    /**
     * @protected
     * @param {Object} note
     * @param {function} callback
     */

    NoteModel.prototype._parseNote = function(note, callback) {
      var content, i, len, line, lines, persons, ref;
      if (!note.content) {
        return callback();
      }
      core.loggers.system.debug("Parsing note was started. guid=" + note.guid);
      content = note.content;
      persons = [];
      content = content.replace(/\r\n|\r|\n|<br\/>|<\/div>|<\/ul>|<\/li>/g, '<>');
      lines = [];
      ref = content.split('<>');
      for (i = 0, len = ref.length; i < len; i++) {
        line = ref[i];
        lines.push(line.replace(/<[^>]*>/g, ''));
      }
      return async.waterfall([
        (function(_this) {
          return function(callback) {
            return core.users[_this._username].models.settings.loadLocal('persons', callback);
          };
        })(this), (function(_this) {
          return function(loadPersons, callback) {
            persons = loadPersons;
            return callback();
          };
        })(this), (function(_this) {
          return function(callback) {
            return core.users[_this._username].models.timeLogs.parse(note, persons, lines, callback);
          };
        })(this), (function(_this) {
          return function(callback) {
            return core.users[_this._username].models.profitLogs.parse(note, lines, callback);
          };
        })(this)
      ], (function(_this) {
        return function(err) {
          core.loggers.system.debug("Parsing note was " + (err ? 'failed' : 'succeed') + ". guid=" + note.guid);
          return callback(err);
        };
      })(this));
    };

    return NoteModel;

  })(MultiModel);

  module.exports = NoteModel;

}).call(this);

//# sourceMappingURL=note-model.js.map
